<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>PVZ mini | æç®€å¡”é˜²</title>
  <style>
    body{
      margin:0; height:100vh; display:grid; place-items:center;
      background:#0b1020; color:#e9eefc;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Arial,"PingFang SC","Microsoft YaHei",sans-serif;
    }
    .wrap{ width:min(980px, 95vw); }
    .top{ display:flex; justify-content:space-between; align-items:baseline; gap:10px; margin:10px 0 10px; }
    .title{ font-weight:800; letter-spacing:.3px; }
    .hint{ opacity:.75; font-size:14px; line-height:1.4; text-align:right; }
    canvas{
      width:100%;
      aspect-ratio: 16/9;
      background: linear-gradient(180deg, #1c2a2b 0%, #122018 50%, #0e1a13 100%);
      border-radius:16px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      touch-action:none;
    }
    .bar{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center; }
    button{
      border:0; border-radius:12px; padding:10px 12px;
      background:#e9eefc; color:#0b1020; font-weight:800; cursor:pointer;
    }
    button:hover{ filter:brightness(.95); }
    a{ color:#9cc0ff; text-decoration:none; font-weight:800; }
    a:hover{ text-decoration:underline; }
    .pill{
      padding:8px 10px; border:1px solid rgba(233,238,252,.25);
      border-radius:999px; font-size:14px; opacity:.95;
      background: rgba(0,0,0,.18);
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">ğŸŒ± PVZ miniï¼šæç®€å¡”é˜²ï¼ˆCanvasï¼‰</div>
      <div class="pill" id="status">åŠ è½½ä¸­â€¦</div>
    </div>
    <div class="hint">
      ç‚¹å‡»æ ¼å­ç§è±Œè±†å°„æ‰‹ï¼ˆ50 é˜³å…‰ï¼‰<br>
      ç©ºæ ¼æš‚åœï½œR é‡å¼€ï½œåƒµå°¸åˆ°å·¦è¾¹å°±è¾“äº†
    </div>
  </div>

  <canvas id="c" width="960" height="540"></canvas>

  <div class="bar">
    <button id="restart">é‡æ–°å¼€å§‹</button>
    <button id="pause">æš‚åœ/ç»§ç»­</button>
    <a href="index.html">â† å›ä¸»é¡µ</a>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');

  // ===== åŸºæœ¬å‚æ•°ï¼ˆä½ æƒ³æ”¹éš¾åº¦å°±æ”¹è¿™é‡Œï¼‰=====
  const LANES = 5;               // è¡Œæ•°
  const COLS  = 9;               // åˆ—æ•°
  const PLANT_COST = 50;         // æ¤ç‰©èŠ±è´¹
  const START_SUN = 100;         // åˆå§‹é˜³å…‰
  const SUN_PER_SEC = 12;        // é˜³å…‰è‡ªåŠ¨å¢é•¿ï¼ˆæ¯ç§’ï¼‰
  const BULLET_DMG = 20;         // å­å¼¹ä¼¤å®³
  const PLANT_FIRE_CD = 0.65;    // å°„é€Ÿï¼ˆç§’ï¼‰
  const ZOMBIE_BASE_HP = 80;     // åŸºç¡€è¡€é‡
  const ZOMBIE_BASE_SPD = 26;    // åŸºç¡€é€Ÿåº¦ï¼ˆåƒç´ /ç§’ï¼‰
  const SPAWN_BASE = 2.2;        // åˆå§‹åˆ·æ€ªé—´éš”ï¼ˆç§’ï¼‰
  const SPAWN_MIN  = 0.75;       // æœ€å¿«åˆ·æ€ªé—´éš”ï¼ˆç§’ï¼‰
  const DIFF_RAMP  = 0.006;      // éš¾åº¦å¢é•¿ï¼ˆè¶Šå¤§è¶Šå¿«ï¼‰

  // ===== DPR é€‚é…ï¼ˆè®©ç”»é¢æ¸…æ™°ï¼‰=====
  function fitDPR(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
  }

  // ===== æ¸¸æˆçŠ¶æ€ =====
  let running = true;
  let gameOver = false;

  let sun = START_SUN;
  let timeAlive = 0;        // å­˜æ´»æ—¶é—´ï¼ˆç”¨äºéš¾åº¦æ›²çº¿ï¼‰
  let score = 0;            // çº¯è®¡åˆ†ï¼šæŒ‰å‡»æ€æ•°+å­˜æ´»æ—¶é—´
  let kills = 0;

  // ç½‘æ ¼ï¼šå­˜æ”¾æ¤ç‰©ï¼ˆåªåš 1 ç§ï¼šè±Œè±†å°„æ‰‹ï¼‰
  const grid = Array.from({length: LANES}, () => Array(COLS).fill(null));
  // å®ä½“åˆ—è¡¨
  const plants = [];
  const zombies = [];
  const bullets = [];

  // åæ ‡æ¢ç®—
  function cellW(){ return canvas.width / COLS; }
  function laneH(){ return canvas.height / LANES; }

  // ===== ç”Ÿæˆå®ä½“ =====
  function addPlant(lane, col){
    if(gameOver) return;
    if(lane < 0 || lane >= LANES || col < 0 || col >= COLS) return;
    if(grid[lane][col]) return;
    if(sun < PLANT_COST) return;

    sun -= PLANT_COST;

    const x = (col + 0.5) * cellW();
    const y = (lane + 0.5) * laneH();
    const p = {
      lane, col, x, y,
      fireCD: 0,
      hp: 9999
    };
    grid[lane][col] = p;
    plants.push(p);
  }

  function spawnZombie(){
    const lane = Math.floor(Math.random() * LANES);
    const y = (lane + 0.5) * laneH();

    // éš¾åº¦éšæ—¶é—´ä¸Šå‡ï¼šè¡€é‡ã€é€Ÿåº¦è½»å¾®ä¸Šå‡
    const hp = ZOMBIE_BASE_HP + Math.floor(timeAlive * 4);
    const spd = ZOMBIE_BASE_SPD + timeAlive * 0.7;

    zombies.push({
      lane,
      x: canvas.width + 30,
      y,
      r: Math.min(laneH()*0.32, 22),
      hp,
      maxHp: hp,
      spd
    });
  }

  function shootFrom(plant){
    // åªå‘å³å°„å‡»
    bullets.push({
      lane: plant.lane,
      x: plant.x + 16,
      y: plant.y,
      vx: 420,
      r: 5,
      dmg: BULLET_DMG
    });
  }

  // ===== è¾“å…¥ï¼šç‚¹å‡»/è§¦æ§ç§æ¤ =====
  function canvasToCell(evt){
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    const sx = (clientX - rect.left) / rect.width  * canvas.width;
    const sy = (clientY - rect.top)  / rect.height * canvas.height;
    const col = Math.floor(sx / cellW());
    const lane = Math.floor(sy / laneH());
    return {lane, col};
  }

  let pointerDown = false;
  canvas.addEventListener('pointerdown', (e)=>{
    pointerDown = true;
    const {lane, col} = canvasToCell(e);
    addPlant(lane, col);
  });
  canvas.addEventListener('pointerup', ()=> pointerDown = false);

  // ===== æ§åˆ¶ï¼šæš‚åœ/é‡å¼€ =====
  function togglePause(){
    if(gameOver) return;
    running = !running;
  }
  function restart(){
    // æ¸…ç©º
    for(let r=0;r<LANES;r++) for(let c=0;c<COLS;c++) grid[r][c]=null;
    plants.length = 0;
    zombies.length = 0;
    bullets.length = 0;

    running = true;
    gameOver = false;

    sun = START_SUN;
    timeAlive = 0;
    score = 0;
    kills = 0;

    spawnTimer = 0;
  }

  window.addEventListener('keydown', (e)=>{
    if(e.key === ' ') { e.preventDefault(); togglePause(); }
    if(e.key === 'r' || e.key === 'R') restart();
  });
  document.getElementById('pause').addEventListener('click', togglePause);
  document.getElementById('restart').addEventListener('click', restart);

  // ===== æ¸¸æˆå¾ªç¯ =====
  let last = performance.now();
  let spawnTimer = 0;

  function update(dt){
    timeAlive += dt;

    // é˜³å…‰è‡ªåŠ¨å¢é•¿
    sun += SUN_PER_SEC * dt;

    // åˆ·æ€ªï¼šéšç€å­˜æ´»æ—¶é—´å˜å¿«
    const spawnInterval = Math.max(SPAWN_MIN, SPAWN_BASE - timeAlive * DIFF_RAMP);
    spawnTimer += dt;
    while(spawnTimer >= spawnInterval){
      spawnTimer -= spawnInterval;
      spawnZombie();
    }

    // æ¤ç‰©å¼€ç«ï¼šè‹¥è¯¥è¡Œå­˜åœ¨åƒµå°¸ä¸”åœ¨æ¤ç‰©å³ä¾§ï¼Œå°±å°„å‡»
    for(const p of plants){
      p.fireCD -= dt;
      if(p.fireCD <= 0){
        const hasTarget = zombies.some(z => z.lane === p.lane && z.x > p.x);
        if(hasTarget){
          shootFrom(p);
          p.fireCD = PLANT_FIRE_CD;
        } else {
          // æ²¡ç›®æ ‡å°±ç¨å¾®æ…¢ä¸€ç‚¹æ£€æŸ¥
          p.fireCD = Math.min(0.25, PLANT_FIRE_CD);
        }
      }
    }

    // å­å¼¹ç§»åŠ¨ & ç¢°æ’
    for(const b of bullets){
      b.x += b.vx * dt;
    }

    // å­å¼¹ç¢°æ’ï¼ˆåŒä¸€è¡Œï¼Œåœ†ç¢°æ’ï¼‰
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      let hit = false;
      for(const z of zombies){
        if(z.lane !== b.lane) continue;
        const dx = z.x - b.x;
        const dy = z.y - b.y;
        const rr = z.r + b.r;
        if(dx*dx + dy*dy <= rr*rr){
          z.hp -= b.dmg;
          hit = true;
          break;
        }
      }
      if(hit || b.x > canvas.width + 40){
        bullets.splice(i,1);
      }
    }

    // åƒµå°¸ç§»åŠ¨ï¼šå‘å·¦ï¼›å¦‚æœèµ°åˆ°æœ€å·¦è¾¹ => è¾“
    for(const z of zombies){
      z.x -= z.spd * dt;
      if(z.x - z.r < 0){
        gameOver = true;
        running = false;
      }
    }

    // æ¸…ç†æ­»äº¡åƒµå°¸
    for(let i=zombies.length-1;i>=0;i--){
      if(zombies[i].hp <= 0){
        zombies.splice(i,1);
        kills += 1;
        // å‡»æ€å¥–åŠ±é˜³å…‰ï¼ˆè®©ç©å®¶æœ‰åé¦ˆï¼‰
        sun += 18;
      }
    }

    // è®¡åˆ†ï¼šå­˜æ´»æ—¶é—´ + å‡»æ€
    score = Math.floor(timeAlive * 10 + kills * 50);
  }

  // ===== æ¸²æŸ“ =====
  function drawGrid(){
    const cw = cellW(), lh = laneH();
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#e9eefc';
    ctx.lineWidth = 2;
    for(let c=1;c<COLS;c++){
      const x = c*cw;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    for(let r=1;r<LANES;r++){
      const y = r*lh;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawPlants(){
    for(const p of plants){
      // è±Œè±†å°„æ‰‹ï¼šç»¿åœ†+ç‚®å£
      ctx.save();
      ctx.translate(p.x, p.y);

      ctx.fillStyle = '#9ef08f';
      ctx.beginPath();
      ctx.arc(0, 0, Math.min(laneH()*0.28, 20), 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#2b5b2c';
      ctx.beginPath();
      ctx.arc(7, -3, 6, 0, Math.PI*2);
      ctx.fill();

      // å°å¶å­
      ctx.fillStyle = '#4ad06b';
      ctx.beginPath();
      ctx.ellipse(-10, 10, 10, 5, -0.6, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  function drawZombies(){
    for(const z of zombies){
      ctx.save();
      ctx.translate(z.x, z.y);

      // èº«ä½“
      ctx.fillStyle = '#b9f2b6';
      ctx.beginPath();
      ctx.roundRect(-z.r, -z.r, z.r*2, z.r*2, 8);
      ctx.fill();

      // çœ¼ç›
      ctx.fillStyle = '#0b1020';
      ctx.beginPath(); ctx.arc(-6, -4, 2.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( 2, -4, 2.5, 0, Math.PI*2); ctx.fill();

      // è¡€æ¡
      const w = z.r*2;
      const hpRate = Math.max(0, z.hp / z.maxHp);
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(-z.r, -z.r-10, w, 6);
      ctx.fillStyle = '#ff7b7b';
      ctx.fillRect(-z.r, -z.r-10, w*hpRate, 6);

      ctx.restore();
    }
  }

  function drawBullets(){
    for(const b of bullets){
      ctx.save();
      ctx.fillStyle = '#f6ff83';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = 'rgba(233,238,252,.92)';
    ctx.font = `${Math.round(canvas.height*0.045)}px Arial`;
    ctx.fillText(`â˜€ é˜³å…‰: ${Math.floor(sun)}`, 14, 40);
    ctx.fillText(`â˜  å‡»æ€: ${kills}`, 14, 80);
    ctx.fillText(`â˜… åˆ†æ•°: ${score}`, 14, 120);

    ctx.textAlign = 'right';
    ctx.fillText(`ç§æ¤èŠ±è´¹: ${PLANT_COST}`, canvas.width - 14, 40);

    if(!running && !gameOver){
      ctx.textAlign = 'center';
      ctx.font = `${Math.round(canvas.height*0.065)}px Arial`;
      ctx.fillText('â¸ å·²æš‚åœï¼ˆç©ºæ ¼ç»§ç»­ï¼‰', canvas.width/2, canvas.height/2);
    }
    if(gameOver){
      ctx.textAlign = 'center';
      ctx.font = `${Math.round(canvas.height*0.08)}px Arial`;
      ctx.fillText('ğŸ’€ åƒµå°¸çªç ´é˜²çº¿ï¼', canvas.width/2, canvas.height*0.42);
      ctx.font = `${Math.round(canvas.height*0.05)}px Arial`;
      ctx.fillText(`åˆ†æ•°ï¼š${score}  ï½œå‡»æ€ï¼š${kills}`, canvas.width/2, canvas.height*0.52);
      ctx.font = `${Math.round(canvas.height*0.04)}px Arial`;
      ctx.fillText('æŒ‰ R æˆ–ç‚¹â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€', canvas.width/2, canvas.height*0.60);
    }
    ctx.restore();

    // é¡¶éƒ¨çŠ¶æ€æ¡
    statusEl.textContent = gameOver ? 'çŠ¶æ€ï¼šç»“æŸ' : (running ? 'çŠ¶æ€ï¼šè¿›è¡Œä¸­' : 'çŠ¶æ€ï¼šæš‚åœ');
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // è‰åœ°ä¸€ç‚¹å±‚æ¬¡
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#2d5c33';
    ctx.fillRect(0, canvas.height*0.55, canvas.width, canvas.height*0.45);
    ctx.restore();

    drawGrid();
    drawPlants();
    drawZombies();
    drawBullets();
    drawHUD();
  }

  // ===== ä¸»å¾ªç¯ =====
  function loop(now){
    fitDPR();
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if(running && !gameOver) update(dt);
    render();

    requestAnimationFrame(loop);
  }

  // roundRect å…¼å®¹ï¼ˆéƒ¨åˆ†è€æµè§ˆå™¨ï¼‰
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y,   x+w, y+h, r);
      this.arcTo(x+w, y+h, x,   y+h, r);
      this.arcTo(x,   y+h, x,   y,   r);
      this.arcTo(x,   y,   x+w, y,   r);
      this.closePath();
      return this;
    }
  }

  // å¯åŠ¨
  requestAnimationFrame(() => {
    fitDPR();
    statusEl.textContent = 'çŠ¶æ€ï¼šè¿›è¡Œä¸­';
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
