<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>å¡”é˜²æ¸¸æˆ | Tower Defense</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
    }
    .container {
      width: min(900px, 95vw);
      padding: 15px;
    }
    .header {
      text-align: center;
      margin-bottom: 12px;
    }
    .title {
      font-size: 28px;
      font-weight: 800;
      margin-bottom: 8px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .game-wrapper {
      position: relative;
      background: #1a1a2e;
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 15px 45px rgba(0,0,0,0.4);
    }
    canvas {
      width: 100%;
      display: block;
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      border-radius: 12px;
      cursor: crosshair;
      touch-action: none;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }
    .hud-item {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .hud-label {
      font-size: 12px;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hud-value {
      font-size: 20px;
      font-weight: 800;
    }
    .tower-selector {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .tower-btn {
      flex: 1;
      min-width: 140px;
      padding: 12px;
      background: rgba(255,255,255,0.15);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }
    .tower-btn:hover {
      background: rgba(255,255,255,0.25);
      transform: translateY(-2px);
    }
    .tower-btn.active {
      background: rgba(46, 213, 115, 0.3);
      border-color: #2ed573;
      box-shadow: 0 0 20px rgba(46, 213, 115, 0.3);
    }
    .tower-btn-name {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .tower-btn-info {
      font-size: 11px;
      opacity: 0.9;
      line-height: 1.3;
    }
    .controls {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    .btn {
      padding: 10px 20px;
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover {
      background: rgba(255,255,255,0.3);
    }
    .btn-primary {
      background: #2ed573;
    }
    .btn-primary:hover {
      background: #26de81;
    }
     .overlay {
       position: absolute;
       top: 10px;
       left: 50%;
       transform: translateX(-50%);
       text-align: center;
       background: rgba(0,0,0,0.85);
       padding: 20px 40px;
       border-radius: 12px;
       backdrop-filter: blur(10px);
       pointer-events: none;
       opacity: 0;
       transition: opacity 0.3s;
       z-index: 100;
     }
     .overlay.show {
       opacity: 1;
       pointer-events: all;
     }
     .overlay.big {
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
       padding: 40px 60px;
     }
     .overlay-title {
       font-size: 24px;
       font-weight: 800;
       margin-bottom: 8px;
     }
     .overlay.big .overlay-title {
       font-size: 36px;
       margin-bottom: 20px;
     }
     .overlay-text {
       font-size: 14px;
       margin-bottom: 0;
       opacity: 0.9;
     }
     .overlay.big .overlay-text {
       font-size: 18px;
       margin-bottom: 30px;
     }
     .help-text {
       text-align: center;
       font-size: 12px;
       opacity: 0.7;
       margin-top: 8px;
       line-height: 1.5;
     }
     .stats-overlay {
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
       background: rgba(0,0,0,0.95);
       padding: 30px 40px;
       border-radius: 16px;
       backdrop-filter: blur(15px);
       pointer-events: none;
       opacity: 0;
       transition: opacity 0.3s;
       z-index: 200;
       max-width: 500px;
       width: 90%;
     }
     .stats-overlay.show {
       opacity: 1;
       pointer-events: all;
     }
     .stats-title {
       font-size: 28px;
       font-weight: 800;
       margin-bottom: 20px;
       text-align: center;
       color: #ffd700;
     }
     .stats-grid {
       display: grid;
       grid-template-columns: repeat(2, 1fr);
       gap: 15px;
       margin: 20px 0;
     }
     .stat-item {
       background: rgba(255,255,255,0.1);
       padding: 12px;
       border-radius: 8px;
       text-align: center;
     }
     .stat-label {
       font-size: 12px;
       opacity: 0.8;
       margin-bottom: 5px;
     }
     .stat-value {
       font-size: 24px;
       font-weight: 800;
       color: #2ecc71;
     }
     .stat-value.gold {
       color: #ffd700;
     }
     .stat-value.red {
       color: #e74c3c;
     }
     .stats-buttons {
       display: flex;
       gap: 10px;
       margin-top: 20px;
     }
     .stats-buttons .btn {
       flex: 1;
     }
   </style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="title">ğŸ° å¡”é˜²æ¸¸æˆ</div>
  </div>
  
  <div class="game-wrapper">
    <div class="hud">
      <div class="hud-item">
        <div class="hud-label">é‡‘å¸</div>
        <div class="hud-value" id="gold">600</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">æ³¢æ¬¡</div>
        <div class="hud-value" id="wave">0/10</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">åŸºåœ°ç”Ÿå‘½</div>
        <div class="hud-value" id="health">12</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">çŠ¶æ€</div>
        <div class="hud-value" id="status" style="font-size: 16px;">å‡†å¤‡ä¸­</div>
      </div>
    </div>
    
    <canvas id="canvas" width="800" height="500"></canvas>
    
    <div class="tower-selector">
      <div class="tower-btn" data-type="basic">
        <div class="tower-btn-name">ğŸ”« åŸºç¡€å¡”</div>
        <div class="tower-btn-info">ğŸ’° 100 | å°„ç¨‹: 120 | ä¼¤å®³: 25</div>
      </div>
      <div class="tower-btn" data-type="sniper">
        <div class="tower-btn-name">ğŸ¯ ç‹™å‡»å¡”</div>
        <div class="tower-btn-info">ğŸ’° 180 | å°„ç¨‹: 200 | ä¼¤å®³: 60</div>
      </div>
      <div class="tower-btn" data-type="machine">
        <div class="tower-btn-name">âš¡ æœºæªå¡”</div>
        <div class="tower-btn-info">ğŸ’° 140 | å°„ç¨‹: 90 | ä¼¤å®³: 10</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn btn-primary" id="startWave">å¼€å§‹æ³¢æ¬¡</button>
      <button class="btn" id="restart">é‡æ–°å¼€å§‹</button>
    </div>
    
     <div class="help-text">
       ğŸ’¡ æç¤ºï¼šç‚¹å‡»å¡”é€‰ä¸­å¹¶åˆ‡æ¢ç­–ç•¥ | åŒå‡»å¡”å‡çº§ | æ¯3æ³¢æœ‰BOSSæ¥è¢­<br>
       âš ï¸ BOSSåˆ°è¾¾åŸºåœ°åä¼šæŒç»­æ”»å‡»ï¼Œæ¯5ç§’-2â¤ï¸ï¼Œå¿…é¡»å‡»è´¥å®ƒï¼
     </div>
    
     <div class="overlay" id="overlay">
       <div class="overlay-title" id="overlayTitle">å‡†å¤‡å¥½äº†å—ï¼Ÿ</div>
       <div class="overlay-text" id="overlayText">ç‚¹å‡»"å¼€å§‹æ³¢æ¬¡"æ¥è¿æˆ˜ç¬¬ä¸€æ³¢æ•Œäººï¼</div>
     </div>
     
     <div class="stats-overlay" id="statsOverlay">
       <div class="stats-title" id="statsTitle">ğŸ‰ æ¸¸æˆç»“ç®—</div>
       <div class="stats-grid" id="statsGrid"></div>
       <div class="stats-buttons">
         <button class="btn btn-primary" id="statsRestart">å†æ¥ä¸€å±€</button>
       </div>
     </div>
   </div>
 </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  
   // DOMå…ƒç´ 
   const goldEl = document.getElementById('gold');
   const waveEl = document.getElementById('wave');
   const healthEl = document.getElementById('health');
   const statusEl = document.getElementById('status');
   const overlayEl = document.getElementById('overlay');
   const overlayTitleEl = document.getElementById('overlayTitle');
   const overlayTextEl = document.getElementById('overlayText');
   const statsOverlayEl = document.getElementById('statsOverlay');
   const statsTitleEl = document.getElementById('statsTitle');
   const statsGridEl = document.getElementById('statsGrid');
  
  // ===== æ¸¸æˆé…ç½® =====
  const CONFIG = {
    // é˜²å¾¡å¡”é…ç½®
    towers: {
      basic: {
        name: 'åŸºç¡€å¡”',
        cost: 100,
        range: 120,
        damage: 25,
        fireRate: 0.9,
        color: '#4a90e2',
        upgradeCost: [70, 110],
        upgradeBonus: { damage: 12, range: 20 }
      },
      sniper: {
        name: 'ç‹™å‡»å¡”',
        cost: 180,
        range: 200,
        damage: 60,
        fireRate: 2.0,
        color: '#e74c3c',
        upgradeCost: [120, 180],
        upgradeBonus: { damage: 30, range: 30 }
      },
      machine: {
        name: 'æœºæªå¡”',
        cost: 140,
        range: 90,
        damage: 10,
        fireRate: 0.28,
        color: '#f39c12',
        upgradeCost: [90, 130],
        upgradeBonus: { damage: 5, range: 15 }
      }
    },
    
    // åŸºåœ°é…ç½®
    base: {
      x: 400,
      y: 250,
      radius: 35,
      maxHealth: 12
    },
    
     // æ³¢æ¬¡é…ç½®
     wave: {
       total: 10,
       baseEnemies: 4,
       enemyIncrement: 3,
       baseHealth: 50,
       healthIncrement: 15,  // åæœŸå¢é•¿æ›´å¿«
       baseSpeed: 45,
       speedIncrement: 4,    // é€Ÿåº¦å¢é•¿æ›´å¿«
       killReward: 20,
       waveReward: 120
     },
     
     // åˆå§‹èµ„æº
     startGold: 700
  };
  
   // ===== æ¸¸æˆçŠ¶æ€ =====
   let gameState = 'prepare'; // prepare, wave, victory, defeat
   let gold = CONFIG.startGold;
   let baseHealth = CONFIG.base.maxHealth;
   let currentWave = 0;
   let selectedTowerType = null;
   let selectedTower = null; // é€‰ä¸­çš„å·²å»ºé€ çš„å¡”
   let enemiesSpawned = 0; // å·²ç”Ÿæˆçš„æ•Œäººæ•°
   let totalEnemiesToSpawn = 0; // æœ¬æ³¢æ€»å…±è¦ç”Ÿæˆçš„æ•Œäººæ•°
   
   const towers = [];
   const enemies = [];
   const bullets = [];
   const particles = [];
   const floatingTexts = [];
   
   let screenShake = 0; // å±å¹•éœ‡åŠ¨å¼ºåº¦
   
   // ===== æ¸¸æˆç»Ÿè®¡æ•°æ® =====
   const gameStats = {
     totalKills: 0,
     bossKills: 0,
     totalDamageDealt: 0,
     totalGoldEarned: 0,
     totalGoldSpent: 0,
     towersBuilt: 0,
     towersUpgraded: 0,
     highestWaveReached: 0,
     gameTime: 0
   };
  
  // ===== é˜²å¾¡å¡”ç±» =====
  class Tower {
     constructor(x, y, type) {
       this.x = x;
       this.y = y;
       this.type = type;
       this.level = 1;
       
       const config = CONFIG.towers[type];
       this.range = config.range;
       this.damage = config.damage;
       this.fireRate = config.fireRate;
       this.color = config.color;
       this.config = config;
       
       this.fireTimer = 0;
       this.target = null;
       this.strategy = 'closest'; // æ”»å‡»ç­–ç•¥: closest, boss, weakest
       this.totalDamage = 0; // ç»Ÿè®¡æ€»ä¼¤å®³
     }
    
    update(dt) {
      this.fireTimer -= dt;
      
      // å¯»æ‰¾ç›®æ ‡
      if (!this.target || this.target.dead || this.getDistance(this.target) > this.range) {
        this.target = this.findTarget();
      }
      
      // å¼€ç«
      if (this.target && this.fireTimer <= 0) {
        this.shoot();
        this.fireTimer = this.fireRate;
      }
    }
    
     findTarget() {
       if (this.strategy === 'boss') {
         // ä¼˜å…ˆæ”»å‡»BOSS
         for (const enemy of enemies) {
           if (enemy.dead) continue;
           if (enemy.isBoss && this.getDistance(enemy) <= this.range) {
             return enemy;
           }
         }
       }
       
       if (this.strategy === 'weakest') {
         // æ”»å‡»è¡€é‡æœ€å°‘çš„æ•Œäººï¼ˆå¿«é€Ÿæ¸…ç†ï¼‰
         let weakest = null;
         let minHealth = Infinity;
         for (const enemy of enemies) {
           if (enemy.dead) continue;
           const dist = this.getDistance(enemy);
           if (dist <= this.range && enemy.health < minHealth) {
             minHealth = enemy.health;
             weakest = enemy;
           }
         }
         if (weakest) return weakest;
       }
       
       // é»˜è®¤ï¼šæ”»å‡»ç¦»åŸºåœ°æœ€è¿‘çš„æ•Œäºº
       let target = null;
       let minDistToBase = Infinity;
       
       for (const enemy of enemies) {
         if (enemy.dead) continue;
         const dist = this.getDistance(enemy);
         if (dist <= this.range) {
           const distToBase = Math.sqrt(
             (enemy.x - CONFIG.base.x) ** 2 + 
             (enemy.y - CONFIG.base.y) ** 2
           );
           if (distToBase < minDistToBase) {
             minDistToBase = distToBase;
             target = enemy;
           }
         }
       }
       
       return target;
     }
     
     changeStrategy() {
       const strategies = ['closest', 'boss', 'weakest'];
       const currentIndex = strategies.indexOf(this.strategy);
       this.strategy = strategies[(currentIndex + 1) % strategies.length];
     }
     
     getStrategyName() {
       const names = {
         closest: 'ä¼˜å…ˆåŸºåœ°',
         boss: 'ä¼˜å…ˆBOSS',
         weakest: 'ä¼˜å…ˆæ®‹è¡€'
       };
       return names[this.strategy] || this.strategy;
     }
    
     shoot() {
       bullets.push(new Bullet(this.x, this.y, this.target, this.damage, this));
     }
    
    getDistance(entity) {
      const dx = entity.x - this.x;
      const dy = entity.y - this.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
     upgrade() {
       if (this.level >= 3) return false;
       
       const cost = this.config.upgradeCost[this.level - 1];
       if (gold < cost) return false;
       
       gold -= cost;
       gameStats.totalGoldSpent += cost;
       gameStats.towersUpgraded++;
       
       this.level++;
       this.damage += this.config.upgradeBonus.damage;
       this.range += this.config.upgradeBonus.range;
       
       return true;
     }
    
    getUpgradeCost() {
      if (this.level >= 3) return null;
      return this.config.upgradeCost[this.level - 1];
    }
    
    draw() {
      // å°„ç¨‹åœˆï¼ˆé€‰ä¸­æ—¶æ˜¾ç¤ºï¼‰
      if (selectedTower === this) {
        ctx.save();
        ctx.strokeStyle = this.color;
        ctx.globalAlpha = 0.25;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        ctx.stroke();
        
        // å¡«å……å°„ç¨‹åœˆ
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      
      // å¡”åº•åº§é˜´å½±
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(this.x + 2, this.y + 18, 18, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // å¡”åº•åº§
      ctx.fillStyle = '#34495e';
      ctx.beginPath();
      ctx.arc(this.x, this.y + 5, 18, 0, Math.PI * 2);
      ctx.fill();
      
      // å¡”èº«
      const gradient = ctx.createRadialGradient(this.x - 5, this.y - 5, 5, this.x, this.y, 15);
      gradient.addColorStop(0, this.color);
      gradient.addColorStop(1, this.darkenColor(this.color, 30));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.fill();
      
      // é«˜å…‰
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(this.x - 4, this.y - 4, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // ç‚®ç®¡ï¼ˆæŒ‡å‘ç›®æ ‡ï¼‰
      if (this.target) {
        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
        const gunLength = 20;
        
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(angle) * gunLength, this.y + Math.sin(angle) * gunLength);
        ctx.stroke();
        
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(angle) * gunLength, this.y + Math.sin(angle) * gunLength);
        ctx.stroke();
      }
      
      // ç­‰çº§æ˜Ÿæ˜Ÿ
      for (let i = 0; i < this.level; i++) {
        ctx.fillStyle = '#ffd700';
        ctx.font = '10px Arial';
        ctx.fillText('â˜…', this.x - 10 + i * 10, this.y - 22);
      }
      
      ctx.restore();
    }
    
    darkenColor(color, percent) {
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) - amt;
      const G = (num >> 8 & 0x00FF) - amt;
      const B = (num & 0x0000FF) - amt;
      return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
        (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
        .toString(16).slice(1);
    }
  }
  
  // ===== æ•Œäººç±» =====
  class Enemy {
    constructor(wave, isBoss = false) {
      // ä»åœ°å›¾è¾¹ç¼˜éšæœºç”Ÿæˆ
      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) { // ä¸Š
        this.x = Math.random() * canvas.width;
        this.y = -20;
      } else if (edge === 1) { // å³
        this.x = canvas.width + 20;
        this.y = Math.random() * canvas.height;
      } else if (edge === 2) { // ä¸‹
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 20;
      } else { // å·¦
        this.x = -20;
        this.y = Math.random() * canvas.height;
      }
      
      this.isBoss = isBoss;
      
       if (isBoss) {
         // BOSSå±æ€§ï¼š12å€è¡€é‡ï¼Œ0.4å€é€Ÿåº¦ï¼ˆéå¸¸æ…¢ä½†è¡€åšï¼‰ï¼Œæ›´å¤§ä½“å‹
         this.maxHealth = (CONFIG.wave.baseHealth + wave * CONFIG.wave.healthIncrement) * 12;
         this.health = this.maxHealth;
         this.speed = (CONFIG.wave.baseSpeed + wave * CONFIG.wave.speedIncrement) * 0.4;
         this.radius = 22;
         this.killReward = CONFIG.wave.killReward * 12;
         this.attackingBase = false; // æ˜¯å¦æ­£åœ¨æ”»å‡»åŸºåœ°
         this.attackTimer = 0; // æ”»å‡»è®¡æ—¶å™¨
         this.attackInterval = 5; // æ¯5ç§’æ”»å‡»ä¸€æ¬¡
         this.attackDamage = 2; // æ¯æ¬¡æ”»å‡»é€ æˆ2ç‚¹ä¼¤å®³
       } else {
        this.maxHealth = CONFIG.wave.baseHealth + wave * CONFIG.wave.healthIncrement;
        this.health = this.maxHealth;
        this.speed = CONFIG.wave.baseSpeed + wave * CONFIG.wave.speedIncrement;
        this.radius = 12;
        this.killReward = CONFIG.wave.killReward;
      }
      
      this.dead = false;
    }
    
     update(dt) {
       if (this.dead) return;
       
       // å‘åŸºåœ°ç§»åŠ¨
       const dx = CONFIG.base.x - this.x;
       const dy = CONFIG.base.y - this.y;
       const dist = Math.sqrt(dx * dx + dy * dy);
       
       if (dist < CONFIG.base.radius + this.radius) {
         // åˆ°è¾¾åŸºåœ°
         if (this.isBoss) {
           // BOSSï¼šå¼€å§‹æ”»å‡»åŸºåœ°
           if (!this.attackingBase) {
             this.attackingBase = true;
             this.attackTimer = 0; // ç«‹å³æ”»å‡»ä¸€æ¬¡
             screenShake = 10;
             
             // æ˜¾ç¤ºBOSSæ”»å‡»åŸºåœ°è­¦å‘Š
             showOverlay('ğŸ”¥ BOSSæ­£åœ¨æ”»å‡»åŸºåœ°ï¼', 'æ¯5ç§’é€ æˆ2ç‚¹ä¼¤å®³ï¼Œå¿«å‡»è´¥å®ƒï¼', 3000);
           }
           
           // BOSSæŒç»­æ”»å‡»åŸºåœ°
           this.attackTimer += dt;
           if (this.attackTimer >= this.attackInterval) {
             this.attackTimer = 0;
             baseHealth -= this.attackDamage;
             
             // æ˜¾ç¤ºæ”»å‡»ä¼¤å®³
             floatingTexts.push(new FloatingText(CONFIG.base.x, CONFIG.base.y - 30, `-${this.attackDamage} â¤ï¸`, '#ff0000'));
             screenShake = 8;
             
             if (baseHealth <= 0) {
               gameOver(false);
             }
           }
           
           // BOSSä¿æŒåœ¨åŸºåœ°è¾¹ç¼˜
           return;
         } else {
           // æ™®é€šæ•Œäººï¼šåˆ°è¾¾åŸºåœ°åæ¶ˆå¤±
           if (!this.reachedBase) {
             this.reachedBase = true;
             this.dead = true;
             baseHealth -= 1;
             
             floatingTexts.push(new FloatingText(CONFIG.base.x, CONFIG.base.y - 30, `-1 â¤ï¸`, '#ff0000'));
             screenShake = 5;
             
             if (baseHealth <= 0) {
               gameOver(false);
             }
           }
           return;
         }
       }
       
       // ç§»åŠ¨
       this.x += (dx / dist) * this.speed * dt;
       this.y += (dy / dist) * this.speed * dt;
     }
    
     takeDamage(damage) {
       this.health -= damage;
       if (this.health <= 0) {
         this.dead = true;
         gold += this.killReward;
         
         // ç»Ÿè®¡å‡»æ€
         gameStats.totalKills++;
         gameStats.totalGoldEarned += this.killReward;
         if (this.isBoss) {
           gameStats.bossKills++;
         }
         
         // BOSSæ­»äº¡éœ‡åŠ¨
         if (this.isBoss) {
           screenShake = 12;
         }
         
         // ç”Ÿæˆæ­»äº¡ç²’å­æ•ˆæœ
         const particleCount = this.isBoss ? 30 : 15;
         const particleColor = this.isBoss ? '#ffa500' : '#ff6b6b';
         for (let i = 0; i < particleCount; i++) {
           particles.push(new Particle(this.x, this.y, particleColor));
         }
         
         // æ˜¾ç¤ºé‡‘å¸è·å¾—
         floatingTexts.push(new FloatingText(this.x, this.y, `+${this.killReward}`, '#ffd700'));
       }
     }
    
    draw() {
      if (this.dead) return;
      
      ctx.save();
      
      // ç§»åŠ¨æ–¹å‘
      const angle = Math.atan2(CONFIG.base.y - this.y, CONFIG.base.x - this.x);
      
       // BOSSç‰¹æ•ˆï¼šå‘å…‰å…‰ç¯
       if (this.isBoss) {
         if (this.attackingBase) {
           // æ”»å‡»åŸºåœ°æ—¶çš„ç‰¹æ•ˆï¼ˆçº¢è‰²è„‰å†²ï¼‰
           const progress = this.attackTimer / this.attackInterval;
           const pulseSize = this.radius + 8 + Math.sin(progress * Math.PI * 2) * 4;
           ctx.globalAlpha = 0.4 + Math.sin(progress * Math.PI * 4) * 0.2;
           ctx.strokeStyle = '#ff0000';
           ctx.lineWidth = 5;
           ctx.beginPath();
           ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);
           ctx.stroke();
           ctx.globalAlpha = 1;
           
           // ç»˜åˆ¶æ”»å‡»è®¡æ—¶è¿›åº¦ç¯
           ctx.strokeStyle = '#ff3300';
           ctx.lineWidth = 3;
           ctx.lineCap = 'round';
           ctx.beginPath();
           ctx.arc(this.x, this.y, this.radius + 12, -Math.PI / 2, 
                   -Math.PI / 2 + Math.PI * 2 * progress);
           ctx.stroke();
         } else {
           // ç§»åŠ¨ä¸­çš„å…‰ç¯
           ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.1;
           ctx.strokeStyle = '#ff6600';
           ctx.lineWidth = 4;
           ctx.beginPath();
           ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);
           ctx.stroke();
           ctx.globalAlpha = 1;
         }
       }
      
      // é˜´å½±
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(this.x + 2, this.y + this.radius + 2, this.radius * 0.8, this.radius * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // èº«ä½“æ¸å˜
      const gradient = ctx.createRadialGradient(
        this.x - this.radius * 0.3, 
        this.y - this.radius * 0.3, 
        this.radius * 0.3,
        this.x, this.y, this.radius
      );
      
      if (this.isBoss) {
        // BOSSé¢œè‰²ï¼šæ©™çº¢è‰²
        gradient.addColorStop(0, '#ff9500');
        gradient.addColorStop(0.5, '#ff6600');
        gradient.addColorStop(1, '#cc3300');
      } else {
        gradient.addColorStop(0, '#ff6b6b');
        gradient.addColorStop(1, '#c92a2a');
      }
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // å¤–è¾¹æ¡†
      ctx.strokeStyle = this.isBoss ? '#ff3300' : '#a61e1e';
      ctx.lineWidth = this.isBoss ? 3 : 2;
      ctx.stroke();
      
      // BOSSç‹å† 
      if (this.isBoss) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ‘‘', this.x, this.y - this.radius - 15);
      }
      
      // çœ¼ç›
      const eyeSize = this.isBoss ? 4 : 3;
      const eyeOffset = this.isBoss ? 6 : 4;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(this.x - eyeOffset, this.y - 2, eyeSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x + eyeOffset, this.y - 2, eyeSize, 0, Math.PI * 2);
      ctx.fill();
      
      // ç³å­”ï¼ˆçœ‹å‘åŸºåœ°ï¼‰
      ctx.fillStyle = this.isBoss ? '#ff0000' : '#000';
      ctx.beginPath();
      ctx.arc(this.x - eyeOffset + Math.cos(angle) * 1.5, this.y - 2 + Math.sin(angle) * 1.5, eyeSize * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x + eyeOffset + Math.cos(angle) * 1.5, this.y - 2 + Math.sin(angle) * 1.5, eyeSize * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      // æ„¤æ€’è¡¨æƒ…
      ctx.strokeStyle = '#000';
      ctx.lineWidth = this.isBoss ? 3 : 2;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(this.x - 3, this.y + 5);
      ctx.lineTo(this.x + 3, this.y + 5);
      ctx.stroke();
      
      // è¡€æ¡èƒŒæ™¯
      const barWidth = this.radius * 2.2;
      const barHeight = this.isBoss ? 8 : 5;
      const healthPercent = Math.max(0, this.health / this.maxHealth);
      
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 12, barWidth, barHeight);
      
      // è¡€æ¡
      const healthColor = this.isBoss ? '#ff6600' : 
                         healthPercent > 0.6 ? '#2ecc71' : 
                         healthPercent > 0.3 ? '#f39c12' : '#e74c3c';
      ctx.fillStyle = healthColor;
      ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 12, barWidth * healthPercent, barHeight);
      
      // è¡€æ¡è¾¹æ¡†
      ctx.strokeStyle = this.isBoss ? '#ffd700' : 'rgba(255,255,255,0.3)';
      ctx.lineWidth = this.isBoss ? 2 : 1;
      ctx.strokeRect(this.x - barWidth/2, this.y - this.radius - 12, barWidth, barHeight);
      
       // BOSSè¡€é‡æ•°å­—
       if (this.isBoss) {
         ctx.fillStyle = '#fff';
         ctx.font = 'bold 10px Arial';
         ctx.textAlign = 'center';
         ctx.strokeStyle = '#000';
         ctx.lineWidth = 3;
         ctx.strokeText(Math.ceil(this.health), this.x, this.y - this.radius - 22);
         ctx.fillText(Math.ceil(this.health), this.x, this.y - this.radius - 22);
         
         // æ”»å‡»åŸºåœ°çŠ¶æ€æç¤º
         if (this.attackingBase) {
           // ç»˜åˆ¶æ”»å‡»è¿çº¿
           const progress = this.attackTimer / this.attackInterval;
           ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + progress * 0.7})`;
           ctx.lineWidth = 3;
           ctx.setLineDash([5, 5]);
           ctx.beginPath();
           ctx.moveTo(this.x, this.y);
           ctx.lineTo(CONFIG.base.x, CONFIG.base.y);
           ctx.stroke();
           ctx.setLineDash([]);
           
           // æ”»å‡»è­¦å‘Šæ–‡å­—
           if (progress > 0.7) {
             ctx.fillStyle = '#ff0000';
             ctx.font = 'bold 12px Arial';
             ctx.fillText('æ”»å‡»ä¸­!', this.x, this.y - this.radius - 35);
           }
         }
       }
       
       ctx.restore();
     }
  }
  
  // ===== æµ®åŠ¨æ–‡å­—ç±» =====
  class FloatingText {
    constructor(x, y, text, color = '#ffd700') {
      this.x = x;
      this.y = y;
      this.text = text;
      this.color = color;
      this.life = 1.0;
      this.vy = -50;
      this.dead = false;
    }
    
    update(dt) {
      this.life -= dt;
      if (this.life <= 0) {
        this.dead = true;
        return;
      }
      this.y += this.vy * dt;
    }
    
    draw() {
      if (this.dead) return;
      
      ctx.save();
      ctx.globalAlpha = this.life;
      ctx.fillStyle = this.color;
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      ctx.strokeText(this.text, this.x, this.y);
      ctx.fillText(this.text, this.x, this.y);
      ctx.restore();
    }
  }
  
  // ===== ç²’å­ç±» =====
  class Particle {
    constructor(x, y, color = '#ff6b6b') {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 150;
      this.vy = (Math.random() - 0.5) * 150;
      this.life = 0.6;
      this.maxLife = 0.6;
      this.size = Math.random() * 4 + 2;
      this.color = color;
      this.dead = false;
    }
    
    update(dt) {
      this.life -= dt;
      if (this.life <= 0) {
        this.dead = true;
        return;
      }
      
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.vy += 200 * dt; // é‡åŠ›
      this.vx *= 0.98; // é˜»åŠ›
    }
    
    draw() {
      if (this.dead) return;
      
      ctx.save();
      ctx.globalAlpha = this.life / this.maxLife;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
  
   // ===== å­å¼¹ç±» =====
   class Bullet {
     constructor(x, y, target, damage, tower) {
       this.x = x;
       this.y = y;
       this.target = target;
       this.damage = damage;
       this.tower = tower;
       this.speed = 500;
       this.dead = false;
       this.trail = [];
     }
    
    update(dt) {
      if (this.dead || this.target.dead) {
        this.dead = true;
        return;
      }
      
      const dx = this.target.x - this.x;
      const dy = this.target.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
       if (dist < 10) {
         // å‡»ä¸­ - ç”Ÿæˆç²’å­æ•ˆæœ
         for (let i = 0; i < 8; i++) {
           particles.push(new Particle(this.target.x, this.target.y, '#ffeb3b'));
         }
         this.target.takeDamage(this.damage);
         
         // ç»Ÿè®¡ä¼¤å®³
         if (this.tower) {
           this.tower.totalDamage += this.damage;
         }
         gameStats.totalDamageDealt += this.damage;
         
         this.dead = true;
         return;
       }
      
      // è®°å½•è½¨è¿¹
      this.trail.push({x: this.x, y: this.y});
      if (this.trail.length > 5) this.trail.shift();
      
      this.x += (dx / dist) * this.speed * dt;
      this.y += (dy / dist) * this.speed * dt;
    }
    
    draw() {
      if (this.dead) return;
      
      ctx.save();
      
      // ç»˜åˆ¶è½¨è¿¹
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < this.trail.length; i++) {
        const t = this.trail[i];
        ctx.fillStyle = '#ffd93d';
        ctx.beginPath();
        ctx.arc(t.x, t.y, 3 * (i / this.trail.length), 0, Math.PI * 2);
        ctx.fill();
      }
      
      // ç»˜åˆ¶å­å¼¹
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ffeb3b';
      ctx.shadowColor = '#ffeb3b';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }
  
  // ===== æ¸¸æˆé€»è¾‘ =====
  function startWave() {
    if (gameState !== 'prepare') return;
    
    currentWave++;
    gameState = 'wave';
    selectedTower = null;
    
     const isBossWave = currentWave % 3 === 0;
     
     // ç”Ÿæˆæ•Œäºº
     let enemyCount = CONFIG.wave.baseEnemies + (currentWave - 1) * CONFIG.wave.enemyIncrement;
     
     if (isBossWave) {
       // BOSSæ³¢ï¼šæ™®é€šæ•Œäººæ•°é‡ä¸å˜ï¼ŒBOSSå’Œå°å…µä¸€èµ·è¿›æ”»
       totalEnemiesToSpawn = enemyCount + 1; // +1 BOSS
       
       // BOSSè­¦å‘Š
       showOverlay('âš ï¸ BOSSæ¥è¢­ï¼', `ç¬¬ ${currentWave} æ³¢ - BOSSå’Œå°å…µåŒæ—¶è¿›æ”»ï¼`, 2000);
     } else {
       totalEnemiesToSpawn = enemyCount;
     }
     
     enemiesSpawned = 0;
     
     // ç”Ÿæˆæ™®é€šæ•Œäºº
     for (let i = 0; i < enemyCount; i++) {
       setTimeout(() => {
         enemies.push(new Enemy(currentWave, false));
         enemiesSpawned++;
       }, i * 800);
     }
     
     // BOSSæ³¢ï¼šBOSSåœ¨æ™®é€šæ•Œäººä¸­é—´å‡ºç°ï¼ˆç¬¬3ä¸ªæ•Œäººçš„ä½ç½®ï¼‰
     if (isBossWave) {
       const bossSpawnIndex = Math.min(2, Math.floor(enemyCount / 2)); // BOSSåœ¨ç¬¬3ä¸ªæˆ–ä¸­é—´ä½ç½®å‡ºç°
       setTimeout(() => {
         enemies.push(new Enemy(currentWave, true));
         enemiesSpawned++;
       }, bossSpawnIndex * 800);
     }
    
    updateHUD();
  }
  
   function waveComplete() {
     gameState = 'prepare';
     gold += CONFIG.wave.waveReward;
     screenShake = 0; // é‡ç½®éœ‡åŠ¨
     
     gameStats.totalGoldEarned += CONFIG.wave.waveReward;
     gameStats.highestWaveReached = Math.max(gameStats.highestWaveReached, currentWave);
     
     if (currentWave >= CONFIG.wave.total) {
       gameOver(true);
     } else {
      const isBossWave = currentWave % 3 === 0;
      const nextIsBossWave = (currentWave + 1) % 3 === 0;
      
      if (isBossWave) {
        showOverlay(`ğŸ‰ BOSSå·²å‡»è´¥ï¼`, `æ³¢æ¬¡ ${currentWave} å®Œæˆï¼è·å¾— ${CONFIG.wave.waveReward} é‡‘å¸`, 2500);
      } else if (nextIsBossWave) {
        showOverlay(`æ³¢æ¬¡ ${currentWave} å®Œæˆï¼`, `âš ï¸ ä¸‹ä¸€æ³¢å°†æœ‰BOSSæ¥è¢­ï¼å‡†å¤‡å¥½äº†å—ï¼Ÿ`, 2500);
      } else {
        showOverlay(`æ³¢æ¬¡ ${currentWave} å®Œæˆï¼`, `è·å¾— ${CONFIG.wave.waveReward} é‡‘å¸å¥–åŠ±`, 2000);
      }
    }
    
    updateHUD();
  }
  
   function gameOver(victory) {
     gameState = victory ? 'victory' : 'defeat';
     
     // å»¶è¿Ÿæ˜¾ç¤ºç»“ç®—ç•Œé¢
     setTimeout(() => {
       showStats(victory);
     }, 500);
   }
  
   function restart() {
     gameState = 'prepare';
     gold = CONFIG.startGold;
     baseHealth = CONFIG.base.maxHealth;
     currentWave = 0;
     selectedTowerType = null;
     selectedTower = null;
     enemiesSpawned = 0;
     totalEnemiesToSpawn = 0;
     screenShake = 0;
     
     towers.length = 0;
     enemies.length = 0;
     bullets.length = 0;
     particles.length = 0;
     floatingTexts.length = 0;
     
     // é‡ç½®ç»Ÿè®¡æ•°æ®
     gameStats.totalKills = 0;
     gameStats.bossKills = 0;
     gameStats.totalDamageDealt = 0;
     gameStats.totalGoldEarned = 0;
     gameStats.totalGoldSpent = 0;
     gameStats.towersBuilt = 0;
     gameStats.towersUpgraded = 0;
     gameStats.highestWaveReached = 0;
     gameStats.gameTime = 0;
     
     hideOverlay();
     hideStats();
     updateHUD();
   }
  
  // ===== UIæ›´æ–° =====
  function updateHUD() {
    goldEl.textContent = gold;
    waveEl.textContent = `${currentWave}/${CONFIG.wave.total}`;
    healthEl.textContent = baseHealth;
    
    if (gameState === 'prepare') {
      statusEl.textContent = currentWave === 0 ? 'å‡†å¤‡ä¸­' : `å‡†å¤‡ä¸‹ä¸€æ³¢`;
    } else if (gameState === 'wave') {
      statusEl.textContent = 'æˆ˜æ–—ä¸­';
    } else if (gameState === 'victory') {
      statusEl.textContent = 'èƒœåˆ©';
    } else {
      statusEl.textContent = 'å¤±è´¥';
    }
  }
  
   function showOverlay(title, text, duration = 0, isBig = false) {
     overlayTitleEl.textContent = title;
     overlayTextEl.textContent = text;
     overlayEl.classList.add('show');
     
     if (isBig) {
       overlayEl.classList.add('big');
     } else {
       overlayEl.classList.remove('big');
     }
     
     if (duration > 0) {
       setTimeout(() => hideOverlay(), duration);
     }
   }
   
   function hideOverlay() {
     overlayEl.classList.remove('show', 'big');
   }
   
   function showStats(victory) {
     statsTitleEl.textContent = victory ? 'ğŸ‰ èƒœåˆ©ï¼æ¸¸æˆç»“ç®—' : 'ğŸ’€ å¤±è´¥ï¼æ¸¸æˆç»“ç®—';
     
     const formatTime = (seconds) => {
       const mins = Math.floor(seconds / 60);
       const secs = Math.floor(seconds % 60);
       return `${mins}:${secs.toString().padStart(2, '0')}`;
     };
     
     // æ‰¾å‡ºè¾“å‡ºæœ€é«˜çš„å¡”
     const bestTower = towers.reduce((best, tower) => 
       !best || tower.totalDamage > best.totalDamage ? tower : best
     , null);
     
     statsGridEl.innerHTML = `
       <div class="stat-item">
         <div class="stat-label">æœ€é«˜æ³¢æ¬¡</div>
         <div class="stat-value">${gameStats.highestWaveReached}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">æ¸¸æˆæ—¶é•¿</div>
         <div class="stat-value">${formatTime(gameStats.gameTime)}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">æ€»å‡»æ€</div>
         <div class="stat-value">${gameStats.totalKills}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">BOSSå‡»æ€</div>
         <div class="stat-value red">${gameStats.bossKills}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">æ€»ä¼¤å®³</div>
         <div class="stat-value">${gameStats.totalDamageDealt.toLocaleString()}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">å»ºé€ é˜²å¾¡å¡”</div>
         <div class="stat-value">${gameStats.towersBuilt}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">å‡çº§æ¬¡æ•°</div>
         <div class="stat-value">${gameStats.towersUpgraded}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">é‡‘å¸æ”¶å…¥</div>
         <div class="stat-value gold">${gameStats.totalGoldEarned}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">é‡‘å¸æ”¯å‡º</div>
         <div class="stat-value">${gameStats.totalGoldSpent}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">MVPé˜²å¾¡å¡”</div>
         <div class="stat-value">${bestTower ? bestTower.config.name : '-'}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">MVPä¼¤å®³</div>
         <div class="stat-value">${bestTower ? bestTower.totalDamage.toLocaleString() : '0'}</div>
       </div>
       <div class="stat-item">
         <div class="stat-label">å‰©ä½™é‡‘å¸</div>
         <div class="stat-value gold">${gold}</div>
       </div>
     `;
     
     statsOverlayEl.classList.add('show');
   }
   
   function hideStats() {
     statsOverlayEl.classList.remove('show');
   }
  
  // ===== é¼ æ ‡è¿½è¸ª =====
  let mouseX = 0;
  let mouseY = 0;
  let mouseInCanvas = false;
  let lastClickTime = 0;
  let lastClickedTower = null;
  
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    mouseInCanvas = true;
  });
  
  canvas.addEventListener('mouseleave', () => {
    mouseInCanvas = false;
  });
  
  // ===== è¾“å…¥å¤„ç† =====
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const now = Date.now();
    
     // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å·²æœ‰çš„å¡”
     let clickedTower = null;
     for (const tower of towers) {
       const dist = Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2);
       if (dist < 20) {
         clickedTower = tower;
         break;
       }
     }
     
     if (clickedTower) {
       // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç­–ç•¥åˆ‡æ¢åŒºåŸŸï¼ˆé¢æ¿åº•éƒ¨ï¼‰
       if (selectedTower === clickedTower && gameState === 'prepare') {
         const panelHeight = 90;
         const panelY = clickedTower.y - panelHeight - 30;
         const strategyBtnY = panelY + 48;
         // å¦‚æœç‚¹å‡»äº†é¢æ¿åŒºåŸŸï¼Œåˆ‡æ¢ç­–ç•¥
         if (y >= panelY && y <= panelY + panelHeight) {
           clickedTower.changeStrategy();
           return;
         }
       }
       
       // åŒå‡»æ£€æµ‹ï¼ˆ300mså†…ç‚¹å‡»åŒä¸€åº§å¡”ï¼‰
      if (gameState === 'prepare' && 
          clickedTower === lastClickedTower && 
          now - lastClickTime < 300) {
        // åŒå‡»å‡çº§
        if (clickedTower.upgrade()) {
          updateHUD();
          floatingTexts.push(new FloatingText(clickedTower.x, clickedTower.y - 30, 'å‡çº§ï¼', '#2ecc71'));
        } else {
          // æ— æ³•å‡çº§
          const cost = clickedTower.getUpgradeCost();
          if (cost === null) {
            floatingTexts.push(new FloatingText(clickedTower.x, clickedTower.y - 30, 'å·²æ»¡çº§', '#ffd700'));
          } else {
            floatingTexts.push(new FloatingText(clickedTower.x, clickedTower.y - 30, 'é‡‘å¸ä¸è¶³', '#ff6b6b'));
          }
        }
        lastClickTime = 0; // é‡ç½®ï¼Œé¿å…ä¸‰å‡»
      } else {
        // å•å‡»é€‰ä¸­å¡”
        selectedTower = clickedTower;
        selectedTowerType = null;
        lastClickedTower = clickedTower;
        lastClickTime = now;
      }
      return;
    }
    
    // å–æ¶ˆé€‰æ‹©
    selectedTower = null;
    lastClickedTower = null;
    
     // å»ºé€ æ–°å¡”
     if (selectedTowerType && gameState === 'prepare') {
       const config = CONFIG.towers[selectedTowerType];
       
       // æ£€æŸ¥é‡‘å¸
       if (gold < config.cost) return;
       
       // æ£€æŸ¥è·ç¦»ï¼ˆä¸èƒ½å¤ªé è¿‘åŸºåœ°æˆ–å…¶ä»–å¡”ï¼‰
       const distToBase = Math.sqrt((CONFIG.base.x - x) ** 2 + (CONFIG.base.y - y) ** 2);
       if (distToBase < CONFIG.base.radius + 50) return;
       
       let tooClose = false;
       for (const tower of towers) {
         const dist = Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2);
         if (dist < 40) {
           tooClose = true;
           break;
         }
       }
       if (tooClose) return;
       
       // å»ºé€ 
       gold -= config.cost;
       gameStats.totalGoldSpent += config.cost;
       gameStats.towersBuilt++;
       
       towers.push(new Tower(x, y, selectedTowerType));
       updateHUD();
     }
   });
  
  // å¡”é€‰æ‹©æŒ‰é’®
  document.querySelectorAll('.tower-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const type = btn.dataset.type;
      
      document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('active'));
      
      if (selectedTowerType === type) {
        selectedTowerType = null;
      } else {
        selectedTowerType = type;
        btn.classList.add('active');
      }
      
      selectedTower = null;
    });
  });
  
  // ï¼ˆå·²ç§»é™¤é”®ç›˜å‡çº§ï¼Œæ”¹ä¸ºåŒå‡»å‡çº§ï¼‰
  
     // æ§åˆ¶æŒ‰é’®
     document.getElementById('startWave').addEventListener('click', startWave);
     document.getElementById('restart').addEventListener('click', restart);
     document.getElementById('statsRestart').addEventListener('click', restart);
  
  // ===== æ¸¸æˆå¾ªç¯ =====
  let lastTime = performance.now();
  
  function update(dt) {
    // æ›´æ–°é˜²å¾¡å¡”
    for (const tower of towers) {
      tower.update(dt);
    }
    
    // æ›´æ–°æ•Œäºº
    for (let i = enemies.length - 1; i >= 0; i--) {
      enemies[i].update(dt);
      if (enemies[i].dead) {
        enemies.splice(i, 1);
      }
    }
    
    // æ›´æ–°å­å¼¹
    for (let i = bullets.length - 1; i >= 0; i--) {
      bullets[i].update(dt);
      if (bullets[i].dead) {
        bullets.splice(i, 1);
      }
    }
    
    // æ›´æ–°ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update(dt);
      if (particles[i].dead) {
        particles.splice(i, 1);
      }
    }
    
    // æ›´æ–°æµ®åŠ¨æ–‡å­—
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      floatingTexts[i].update(dt);
      if (floatingTexts[i].dead) {
        floatingTexts.splice(i, 1);
      }
    }
    
    // æ£€æŸ¥æ³¢æ¬¡æ˜¯å¦ç»“æŸï¼ˆæ‰€æœ‰æ•Œäººå·²ç”Ÿæˆä¸”éƒ½è¢«æ¶ˆç­ï¼‰
    if (gameState === 'wave' && enemies.length === 0 && enemiesSpawned >= totalEnemiesToSpawn) {
      waveComplete();
    }
    
    updateHUD();
  }
  
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // åº”ç”¨å±å¹•éœ‡åŠ¨
    ctx.save();
    if (screenShake > 0) {
      const offsetX = (Math.random() - 0.5) * screenShake;
      const offsetY = (Math.random() - 0.5) * screenShake;
      ctx.translate(offsetX, offsetY);
    }
    
    // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let x = 0; x < canvas.width; x += 50) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    ctx.restore();
    
    // ç»˜åˆ¶åŸºåœ°
    ctx.save();
    
    // åŸºåœ°å¤–åœˆ
    ctx.strokeStyle = '#2980b9';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(CONFIG.base.x, CONFIG.base.y, CONFIG.base.radius + 10, 0, Math.PI * 2);
    ctx.stroke();
    
    // åŸºåœ°é˜´å½±
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(CONFIG.base.x + 3, CONFIG.base.y + CONFIG.base.radius + 5, 
                CONFIG.base.radius * 0.9, CONFIG.base.radius * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // åŸºåœ°æ¸å˜
    const baseGradient = ctx.createRadialGradient(
      CONFIG.base.x - 15, CONFIG.base.y - 15, 10,
      CONFIG.base.x, CONFIG.base.y, CONFIG.base.radius
    );
    baseGradient.addColorStop(0, '#5dade2');
    baseGradient.addColorStop(1, '#2874a6');
    ctx.fillStyle = baseGradient;
    ctx.beginPath();
    ctx.arc(CONFIG.base.x, CONFIG.base.y, CONFIG.base.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // åŸºåœ°é«˜å…‰
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(CONFIG.base.x - 10, CONFIG.base.y - 10, 15, 0, Math.PI * 2);
    ctx.fill();
    
    // åŸºåœ°å›¾æ ‡
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 4;
    ctx.fillText('ğŸ°', CONFIG.base.x, CONFIG.base.y);
    
    // åŸºåœ°è¡€é‡ç¯
    const healthPercent = baseHealth / CONFIG.base.maxHealth;
    ctx.strokeStyle = healthPercent > 0.6 ? '#2ecc71' : 
                     healthPercent > 0.3 ? '#f39c12' : '#e74c3c';
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(CONFIG.base.x, CONFIG.base.y, CONFIG.base.radius + 18, 
            -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * healthPercent);
    ctx.stroke();
    
    ctx.restore();
    
    // ç»˜åˆ¶å»ºå¡”é¢„è§ˆ
    if (selectedTowerType && gameState === 'prepare' && mouseInCanvas) {
      const config = CONFIG.towers[selectedTowerType];
      
      // æ£€æŸ¥æ˜¯å¦å¯ä»¥å»ºé€ 
      const distToBase = Math.sqrt((CONFIG.base.x - mouseX) ** 2 + (CONFIG.base.y - mouseY) ** 2);
      let canBuild = gold >= config.cost && distToBase >= CONFIG.base.radius + 50;
      
      if (canBuild) {
        for (const tower of towers) {
          const dist = Math.sqrt((tower.x - mouseX) ** 2 + (tower.y - mouseY) ** 2);
          if (dist < 40) {
            canBuild = false;
            break;
          }
        }
      }
      
      // ç»˜åˆ¶é¢„è§ˆ
      ctx.save();
      ctx.globalAlpha = 0.6;
      
      // å°„ç¨‹åœˆ
      ctx.strokeStyle = canBuild ? config.color : '#e74c3c';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, config.range, 0, Math.PI * 2);
      ctx.stroke();
      
      // å¡”èº«
      ctx.fillStyle = canBuild ? config.color : '#e74c3c';
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // ç»˜åˆ¶é˜²å¾¡å¡”
    for (const tower of towers) {
      tower.draw();
    }
    
    // ç»˜åˆ¶å­å¼¹
    for (const bullet of bullets) {
      bullet.draw();
    }
    
    // ç»˜åˆ¶æ•Œäºº
    for (const enemy of enemies) {
      enemy.draw();
    }
    
    // ç»˜åˆ¶ç²’å­
    for (const particle of particles) {
      particle.draw();
    }
    
    // ç»˜åˆ¶æµ®åŠ¨æ–‡å­—
    for (const text of floatingTexts) {
      text.draw();
    }
    
    // ç»˜åˆ¶å¡”ä¿¡æ¯é¢æ¿
    if (selectedTower && gameState === 'prepare') {
      const cost = selectedTower.getUpgradeCost();
      const panelWidth = 160;
      const panelHeight = 90;
      const panelX = selectedTower.x - panelWidth / 2;
      const panelY = selectedTower.y - panelHeight - 30;
      
      ctx.save();
      
      // é¢æ¿èƒŒæ™¯
      ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
      ctx.strokeStyle = selectedTower.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 10);
      ctx.fill();
      ctx.stroke();
      
       // å¡”ä¿¡æ¯
       ctx.fillStyle = '#fff';
       ctx.font = 'bold 14px Arial';
       ctx.textAlign = 'center';
       ctx.fillText(`${selectedTower.config.name} Lv.${selectedTower.level}`, selectedTower.x, panelY + 18);
       
       ctx.font = '10px Arial';
       ctx.fillStyle = '#aaa';
       ctx.fillText(`ä¼¤å®³: ${Math.round(selectedTower.damage)} | å°„ç¨‹: ${Math.round(selectedTower.range)}`, selectedTower.x, panelY + 32);
       
       // æ”»å‡»ç­–ç•¥åˆ‡æ¢æŒ‰é’®
       const stratY = panelY + 45;
       ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
       ctx.beginPath();
       ctx.roundRect(selectedTower.x - 40, stratY, 80, 18, 4);
       ctx.fill();
       ctx.fillStyle = '#5dade2';
       ctx.font = 'bold 10px Arial';
       ctx.fillText(`ğŸ¯ ${selectedTower.getStrategyName()}`, selectedTower.x, stratY + 12);
       
       // åŒå‡»å‡çº§æç¤º
       if (cost !== null) {
         const canAfford = gold >= cost;
         
         // æç¤ºæ¡†
         ctx.fillStyle = canAfford ? 'rgba(46, 204, 113, 0.2)' : 'rgba(231, 76, 60, 0.2)';
         ctx.beginPath();
         ctx.roundRect(panelX + 10, panelY + 65, panelWidth - 20, 20, 4);
         ctx.fill();
         
         // æç¤ºæ–‡å­—
         ctx.fillStyle = canAfford ? '#2ecc71' : '#e74c3c';
         ctx.font = 'bold 10px Arial';
         ctx.fillText(`åŒå‡»å‡çº§ (ğŸ’°${cost})`, selectedTower.x, panelY + 79);
       } else {
         ctx.fillStyle = '#ffd700';
         ctx.font = 'bold 11px Arial';
         ctx.fillText('â­ å·²æ»¡çº§ â­', selectedTower.x, panelY + 79);
       }
       
       ctx.restore();
     }
    
    // æ¢å¤å±å¹•éœ‡åŠ¨çš„transform
    ctx.restore();
  }
  
   function loop() {
     const now = performance.now();
     const dt = Math.min((now - lastTime) / 1000, 0.1);
     lastTime = now;
     
     if (gameState === 'wave') {
       gameStats.gameTime += dt;
     }
     
     // å±å¹•éœ‡åŠ¨è¡°å‡ï¼ˆå§‹ç»ˆè¿è¡Œï¼‰
    if (screenShake > 0) {
      screenShake -= dt * 30;
      if (screenShake < 0) screenShake = 0;
    }
    
    if (gameState === 'wave') {
      update(dt);
    }
    
    draw();
    
    requestAnimationFrame(loop);
  }
  
   // ===== å¯åŠ¨æ¸¸æˆ =====
   updateHUD();
   showOverlay('ğŸ® å¡”é˜²æ¸¸æˆ', 'å»ºé€ é˜²å¾¡å¡”ä¿å«åŸºåœ°ï¼åŒå‡»é˜²å¾¡å¡”å¯å‡çº§', 3500, true);
   
   requestAnimationFrame(loop);
})();
</script>
</body>
</html>

